out_dir <- "../../data/ofav/ngsAdmix/ofavQ_sorted"   # new folder for reordered files
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be ~800
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
q_fmt <- apply(q_sorted, 2, function(col) sprintf("%.20f", as.numeric(col))) # convert to fixed decimal format, 20 decimal places
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_mat <- as.matrix(df_sorted[, -(1:2), drop = FALSE])     # drop metadata columns
if (ncol(q_mat) == 0) {
stop("No Q columns found in file: ", file,
" â€” check that your original Q has membership columns.")
}
q_fmt <- matrix(
sprintf("%.20f", as.numeric(q_mat)),
nrow = nrow(q_mat),
ncol = ncol(q_mat)
) # convert to fixed decimal format, 20 decimal places
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be ~800
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
q_fmt <- apply(q_sorted, 2, function(col) sprintf("%.20f", as.numeric(col))) # convert to fixed decimal format, 20 decimal places
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be ~800
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_mat <- as.matrix(df_sorted[, -(1:2), drop = FALSE])     # drop metadata columns
q_fmt <- formatC(q_mat, digits = 20, format = "f") # convert to fixed decimal format, 20 decimal places
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
test_file <- q_files[1]
q_test  <- read.table(test_file, header = FALSE)
q_out   <- read.table(file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(test_file)),
header = FALSE)
dim(q_test)
dim(q_out)
head(q_out, 3)
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be ~800
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
dir.create(out_dir, showWarnings = FALSE)
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
q_mat    <- as.matrix(q_sorted)     # keep as matrix
q_fmt <- formatC(q_mat, digits = 20, format = "f") # format with 20 decimal places, no scientific notation
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
dir.create(out_dir, showWarnings = FALSE)
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_mat <- as.matrix(df_sorted[, -(1:2), drop = FALSE])  # drop metadata columns, keep as matrix
q_char_vec <- sprintf("%.20f", as.numeric(q_mat)) # format with 20 decimal places, no scientific notation
# reshape back to matrix with same dimensions
q_fmt <- matrix(
q_char_vec,
nrow = nrow(q_mat),
ncol = ncol(q_mat),
byrow = FALSE  # fill by column, matching original storage
)
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
df_sorted
View(df_sorted)
View(popfile_sorted)
View(df)
q <- read.table(ofav_k3_run16.Q, header=FALSE)
q <- read.table("../../data/ofav/ngsAdmix/ofavQ_sorted/ofav_k3_run16.Q", header=FALSE)
View(q)
options(scipen=999)
q <- read.table("../../data/ofav/ngsAdmix/ofavQ_sorted/ofav_k3_run16.Q", header=FALSE)
View(q)
dir.create(out_dir, showWarnings = FALSE)
for (file in q_files) {
q <- read.table(file, header=FALSE)
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
dir.create(out_dir, showWarnings = FALSE)
for (file in q_files) {
q <- read.table(file, header=FALSE, colClasses = "character")
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
df <- cbind(popfile_sorted, q)
df_sorted <- df[order(df$site), ]   # uses your factor-based ordering
q_sorted <- df_sorted[, -(1:2)]     # drop metadata columns
out_file <- file.path("../../data/ofav/ngsAdmix/ofavQ_sorted", basename(file))
write.table(q_sorted, out_file, quote=FALSE,
row.names=FALSE, col.names=FALSE)
}
# Cleanup
unlink(q_dir, recursive = TRUE) # Delete the uncompressed ofavQ directory
# Zip the ofavQ_sorted directory
out_dir <- normalizePath("../../data/ofav/ngsAdmix/ofavQ_sorted")
files_to_zip <- list.files(out_dir, full.names = TRUE)
zipfile_path <- file.path(dirname(out_dir), "ofavQ_sorted.zip")
zip(zipfile = zipfile_path, files = files_to_zip)
unlink(out_dir, recursive = TRUE) # Delete the uncompressed ofavQ_sorted directory
popfile <- read.table(file = "../../data/ofav/ngsAdmix/ofavPopfile.txt", header = FALSE, col.names=c("sample", "site"), stringsAsFactors=FALSE)
site_order <- c(
"EmeraldReef",
"RainbowReef",
"FisherIsland",
"CoralCityCamera",
"StarIsland",
"MacArthurNorth",
"SouthCanyonReef",
"PillarsReef",
"FIUBiscayneBay",
"GracelandReef",
"FTL4Reef",
"BC1Reef",
"T328Reef"
)
site_factor <- factor(popfile$site, levels = site_order)
ord <- order(site_factor)
popfile_sorted <- popfile[ord, ]
write.table(popfile_sorted, "../../data/ofav/ngsAdmix/ofavPopfile_sorted.txt",
quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
# Unzips, loops through, and reorders each .Q file based on popfile_sorted
unzip("../../data/ofav/ngsAdmix/ofavQ.zip", exdir = "../../data/ofav/ngsAdmix/")
q_dir  <- "../../data/ofav/ngsAdmix/ofavQ"              # where .Q files now live
out_dir <- "../../data/ofav/ngsAdmix/ofavQ_sorted"   # new folder for reordered files
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be 800
for (file in q_files) {
q <- read.table(file, header=FALSE, colClasses = "character")
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
q_sorted <- q[ord, ]
out_file <- file.path(out_dir, basename(file))
write.table(
q_sorted,
out_file,
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
}
# Cleanup
unlink(q_dir, recursive = TRUE) # Delete the uncompressed ofavQ directory
# Zip the ofavQ_sorted directory
out_dir <- normalizePath("../../data/ofav/ngsAdmix/ofavQ_sorted")
files_to_zip <- list.files(out_dir, full.names = TRUE)
zipfile_path <- file.path(dirname(out_dir), "ofavQ_sorted.zip")
zip(zipfile = zipfile_path, files = files_to_zip)
unlink(out_dir, recursive = TRUE) # Delete the uncompressed ofavQ_sorted directory
popfile <- read.table(file = "../../data/ofav/ngsAdmix/ofavPopfile.txt", header = FALSE, col.names=c("sample", "site"), stringsAsFactors=FALSE)
site_order <- c(
"EmeraldReef",
"RainbowReef",
"FisherIsland",
"CoralCityCamera",
"StarIsland",
"MacArthurNorth",
"SouthCanyonReef",
"PillarsReef",
"FIUBiscayneBay",
"GracelandReef",
"FTL4Reef",
"BC1Reef",
"T328Reef"
)
site_factor <- factor(popfile$site, levels = site_order)
ord <- order(site_factor)
popfile_sorted <- popfile[ord, ]
write.table(popfile_sorted, "../../data/ofav/ngsAdmix/ofavPopfile_sorted.txt",
quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
# Unzips, loops through, and reorders each .Q file based on popfile_sorted
unzip("../../data/ofav/ngsAdmix/ofavQ.zip", exdir = "../../data/ofav/ngsAdmix/")
q_dir  <- "../../data/ofav/ngsAdmix/ofavQ"              # where .Q files now live
out_dir <- "../../data/ofav/ngsAdmix/ofavQ_sorted"   # new folder for reordered files
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be 800
for (file in q_files) {
q <- read.table(file, header=FALSE, colClasses = "character")
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
q_sorted <- q[ord, ]
out_file <- file.path(out_dir, basename(file))
write.table(
q_sorted,
out_file,
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
}
# Cleanup
unlink(q_dir, recursive = TRUE) # Delete the uncompressed ofavQ directory
# Zip the ofavQ_sorted directory
out_dir_norm <- normalizePath(out_dir)
parent_dir   <- dirname(out_dir_norm)
old_wd <- getwd()
setwd(parent_dir)
zipfile_path <- file.path(parent_dir, "ofavQ_sorted.zip")
zip(zipfile = zipfile_path, files = "ofavQ_sorted")
parent_dir
out_dir_norm
parent_dir
parent_dir
# Zip the ofavQ_sorted directory
out_dir_norm <- normalizePath(out_dir)
parent_dir   <- dirname(out_dir_norm)
old_wd <- getwd()
setwd(parent_dir)
list.dirs(recursive = FALSE)
parent_dir
zipfile_path
# Zip the ofavQ_sorted directory
out_dir_norm <- normalizePath(out_dir)
parent_dir   <- dirname(out_dir_norm)
folder_name  <- basename(out_dir_norm)
old_wd <- getwd()
old_wd
setwd(parent_dir)
zip(
zipfile = file.path(parent_dir, "ofavQ_sorted.zip"),
files   = folder_name
)
popfile <- read.table(file = "../../data/ofav/ngsAdmix/ofavPopfile.txt", header = FALSE, col.names=c("sample", "site"), stringsAsFactors=FALSE)
site_order <- c(
"EmeraldReef",
"RainbowReef",
"FisherIsland",
"CoralCityCamera",
"StarIsland",
"MacArthurNorth",
"SouthCanyonReef",
"PillarsReef",
"FIUBiscayneBay",
"GracelandReef",
"FTL4Reef",
"BC1Reef",
"T328Reef"
)
site_factor <- factor(popfile$site, levels = site_order)
ord <- order(site_factor)
popfile_sorted <- popfile[ord, ]
write.table(popfile_sorted, "../../data/ofav/ngsAdmix/ofavPopfile_sorted.txt",
quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
# Unzips, loops through, and reorders each .Q file based on popfile_sorted
unzip("../../data/ofav/ngsAdmix/ofavQ.zip", exdir = "../../data/ofav/ngsAdmix/")
q_dir  <- "../../data/ofav/ngsAdmix/ofavQ"              # where .Q files now live
out_dir <- "../../data/ofav/ngsAdmix/ofavQ_sorted"   # new folder for reordered files
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be 800
for (file in q_files) {
q <- read.table(file, header=FALSE, colClasses = "character")
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
q_sorted <- q[ord, ]
out_file <- file.path(out_dir, basename(file))
write.table(
q_sorted,
out_file,
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
}
# Cleanup
unlink(q_dir, recursive = TRUE) # Delete the uncompressed ofavQ directory
# Zip the ofavQ_sorted directory
out_dir_norm <- normalizePath(out_dir)
parent_dir   <- dirname(out_dir_norm)
folder_name  <- basename(out_dir_norm)
old_wd <- getwd()
setwd(parent_dir)
zip(
zipfile = file.path(parent_dir, "ofavQ_sorted.zip"),
files   = folder_name
)
install.packages("zip")   # you only need this once
library(zip)
popfile <- read.table(file = "../../data/ofav/ngsAdmix/ofavPopfile.txt", header = FALSE, col.names=c("sample", "site"), stringsAsFactors=FALSE)
site_order <- c(
"EmeraldReef",
"RainbowReef",
"FisherIsland",
"CoralCityCamera",
"StarIsland",
"MacArthurNorth",
"SouthCanyonReef",
"PillarsReef",
"FIUBiscayneBay",
"GracelandReef",
"FTL4Reef",
"BC1Reef",
"T328Reef"
)
site_factor <- factor(popfile$site, levels = site_order)
ord <- order(site_factor)
popfile_sorted <- popfile[ord, ]
write.table(popfile_sorted, "../../data/ofav/ngsAdmix/ofavPopfile_sorted.txt",
quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
# Unzips, loops through, and reorders each .Q file based on popfile_sorted
unzip("../../data/ofav/ngsAdmix/ofavQ.zip", exdir = "../../data/ofav/ngsAdmix/")
q_dir  <- "../../data/ofav/ngsAdmix/ofavQ"              # where .Q files now live
out_dir <- "../../data/ofav/ngsAdmix/ofavQ_sorted"   # new folder for reordered files
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be 800
for (file in q_files) {
q <- read.table(file, header=FALSE, colClasses = "character")
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
q_sorted <- q[ord, ]
out_file <- file.path(out_dir, basename(file))
write.table(
q_sorted,
out_file,
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
}
# Cleanup
unlink(q_dir, recursive = TRUE) # Delete the uncompressed ofavQ directory
# Zip the ofavQ_sorted directory
out_dir_norm <- normalizePath(out_dir)
parent_dir   <- dirname(out_dir_norm)
folder_name  <- basename(out_dir_norm)
zipfile_path <- file.path(parent_dir, "ofavQ_sorted.zip")
zip::zipr_relative(
zipfile = zipfile_path,
files   = folder_name,
root    = parent_dir
)
cmd <- sprintf(
'cd "%s" && zip -r "%s" "%s"',
parent_dir,
basename(zipfile_path),
folder_name
)
cat("Running command:\n", cmd, "\n")
system(cmd)
if (file.exists(zipfile_path)) {
unlink(out_dir_norm, recursive = TRUE)
} # Delete the uncompressed ofavQ_sorted directory
setwd("~/Documents/GitHub/Urban-coral-population-genetics/code/cnat")
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
popfile <- read.table(file = "../../data/ofav/ngsAdmix/ofavPopfile.txt", header = FALSE, col.names=c("sample", "site"), stringsAsFactors=FALSE)
site_order <- c(
"EmeraldReef",
"RainbowReef",
"BillBaggs",
"Seaquarium",
"FisherIsland",
"CoralCityCamera",
"StarIsland",
"MacArthurNorth",
"BelleIsle",
"SouthCanyonReef",
"PillarsReef",
"ArchCreek",
"FIUBiscayneBay",
"FTL4Reef",
"BC1Reef",
"PeanutIsland"
)
site_factor <- factor(popfile$site, levels = site_order)
ord <- order(site_factor)
popfile_sorted <- popfile[ord, ]
write.table(popfile_sorted, "../../data/ofav/ngsAdmix/ofavPopfile_sorted.txt",
quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
setwd("~/Documents/GitHub/Urban-coral-population-genetics/code/cnat")
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
library(tidyverse)
popfile <- read.table(file = "../../data/cnat/ngsAdmix/cnatPopfile.txt", header = FALSE, col.names=c("sample", "site"), stringsAsFactors=FALSE)
site_order <- c(
"EmeraldReef",
"RainbowReef",
"BillBaggs",
"Seaquarium",
"FisherIsland",
"CoralCityCamera",
"StarIsland",
"MacArthurNorth",
"BelleIsle",
"SouthCanyonReef",
"PillarsReef",
"ArchCreek",
"FIUBiscayneBay",
"FTL4Reef",
"BC1Reef",
"PeanutIsland"
)
site_factor <- factor(popfile$site, levels = site_order)
ord <- order(site_factor)
popfile_sorted <- popfile[ord, ]
write.table(popfile_sorted, "../../data/cnat/ngsAdmix/cnatPopfile_sorted.txt",
quote=FALSE, row.names=FALSE, col.names=FALSE, sep="\t")
# Unzips, loops through, and reorders each .Q file based on popfile_sorted
unzip("../../data/cnat/ngsAdmix/cnatQ.zip", exdir = "../../data/cnat/ngsAdmix/")
q_dir  <- "../../data/cnat/ngsAdmix/cnatQ"              # where .Q files now live
out_dir <- "../../data/cnat/ngsAdmix/cnatQ_sorted"   # new folder for reordered files
dir.create(out_dir, showWarnings = FALSE)
q_files <- list.files(q_dir, pattern="\\.Q$|\\.qopt$", full.names=TRUE)
length(q_files) # should be 800
for (file in q_files) {
q <- read.table(file, header=FALSE, colClasses = "character")
# must have same number of rows
stopifnot(nrow(q) == nrow(popfile_sorted))
q_sorted <- q[ord, ]
out_file <- file.path(out_dir, basename(file))
write.table(
q_sorted,
out_file,
quote = FALSE,
row.names = FALSE,
col.names = FALSE
)
}
# Cleanup
unlink(q_dir, recursive = TRUE) # Delete the uncompressed cnatQ directory
# Zip the cnatQ_sorted directory
out_dir_norm <- normalizePath(out_dir)
parent_dir   <- dirname(out_dir_norm)
folder_name  <- basename(out_dir_norm)
zipfile_path <- file.path(parent_dir, "cnatQ_sorted.zip")
cmd <- sprintf(
'cd "%s" && zip -r "%s" "%s"',
parent_dir,
basename(zipfile_path),
folder_name
)
cat("Running command:\n", cmd, "\n")
system(cmd)
if (file.exists(zipfile_path)) {
unlink(out_dir_norm, recursive = TRUE)
} # Delete the uncompressed cnatQ_sorted directory
